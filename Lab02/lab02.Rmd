---
title: "<img src=\"unive_0.jpg\" /> Network manipulation in R"
author: | 
  | Angela Andreella 
  | Ca' Foscari University of Venice
  | angela.andreella@unive.it
date: '2022-06-28'
output:
  prettydoc::html_pretty:
    theme: tactile
    highlight: github
    df_print: paged
    toc: true
    number_sections: true
fontsize: 11pt
geometry: margin = 1in
---

<style type="text/css">
.main-container {
  max-width: 1100px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, fig.align = "center", out.width = '80%', warning = F, message = F)
```

# Introduction

The material is based on [Ognyanova, K. (2021) Network visualization with R](https://kateto.net/network-visualization). Special thanks also to Emanuele Aliverti for the material.

In network maps several key elements are used to control the outcome. The major ones are *color*, *size*, *shape*, and *position*.

<center>
![](Images/elements_network.png){ width=80% }
</center>

> `r emo::ji("boom")` **_Please note_** _*Arrows* shows the direction of the relationship, and *labels* the identification._

The main package we are going to use is the package `igraph`.

```{r, eval = FALSE}
install.packages("igraph") 
```

# 3 million Russian troll tweets

In this tutorial, we will analyze data used in the FiveThirtyEight story [Why Weâ€™re Sharing 3 Million Russian Troll Tweets](https://fivethirtyeight.com/features/why-were-sharing-3-million-russian-troll-tweets/). The original dataset is composed by $3$ million of tweets from suspected twitter account. The data are preprocessed, if you want to see the original data set, please see this [link](https://www.kaggle.com/fivethirtyeight/russian-troll-tweets).

We want to analyze the interaction structure between these twitter profiles, excluding (in this case) the interaction (comment/retweet), the direction, and the number of time this interaction appear (size of the edge). You can find the dataset in the `Datasets` folder. It is composed by two matrices, `Y` descibes the edges (two-column matrix, where each row defines one edge), while `X` report some information about the nodes (i.e., twitter profiles, $1245$ in total):

- *accountcategory*: main category for type of account, e.g., Commercial, NewsFeed, etc;

- *accounttype*: type of account;

- *activity*: number of activities;

- *maxfollowers*: maximum number of followers profiles;

- *maxfollowing*: maximum number of following profiles;

- *maxpostdate*: last registered post;

- *minfollowers*: minimum number of followers profiles;

- *minfollowing*: minimum number of following profiles;

- *minpostdate*: first registered post;

- *vertex.names*: name of the twitter account (i.e., the name of the node of the graph).

# Edge, vertex and attributes

First of all, we must load the dataset and the `igraph` package. You can find the dataset `russian_trolls` in `Lab02/Datasets`. 

```{r}
load("Datasets/russian_trolls.RData")
library(igraph)
```

:::: {style="display: grid; grid-template-columns: auto auto; grid-column-gap: 5px; place-items: start;"}
::: {}
__R commands__ 

```{r}
net = graph_from_edgelist(Y,directed = F)
for(j in 1:ncol(X)){ 
  net = net %>% 
    set_vertex_attr(name = colnames(X)[j],
                    value = X[,j]) 
}
V(net)$name = V(net)$vertex.names
```
:::
::: {}
__Comments__ 

* `graph_from_edgelist(x)` -- creates a graph from an edge list `x`.
* `set_vertex_attr(name = x, value = y)` -- set vertex attributes, where `x` is the name of the attribute, and `y` is the value of the attribute.
* In the last line we name the nodes using the variable `vertex.names`, we can access to the vertex-level name of the graph `x` attribute by `V(x)$name`.
:::
::::

> `r emo::ji("boom")` **_Please note_** _you can create the `igraph` graph object also if you have a data.frame thanks to the `graph_from_data_frame` function (or you can transform the edgelist as data.frame or reverse). There is also the function `graph_from_adjacency_matrix` to create an `igraph` graph object from adjancency matrices._

Let take a look of our new graph:

```{r}
summary(net)
```

The `igraph` objects is described by four letters:

1. *D* or U for directed or undirected graph
2. *N* for named graph (where nodes have a name attribute)
3. *W* for a weighted graph (where edges have a weight attribute)
4. *B* for a bipartite (two-mode) graph (where nodes have a type attribute)

So, there are two numbers (1245 and 2857) which refer to the number of nodes and edges in the graph.

Then, we have the list of node and edge attributes. For example (v/c) is vertex-level character attribute.

Before we saw how see the vertex-level attribute `name`. You can access to nodes, edges and their attributes by:


:::: {style="display: grid; grid-template-columns: auto auto; grid-column-gap: 5px; place-items: start;"}
::: {}
__R commands__ 

```{r}
E(net) 
V(net)
list.vertex.attributes(net)
```
:::
::: {}
__Comments__ 

* `E(x)`: call the edge sequence of graph `x`;
* `V(x)`: call the vertex sequence of graph `x`;
* `list.vertex.attributes(x)`: return the list names of vertex attributes of graph `x `.
:::
::::

# Degree, geodesic distance, closeness, and betweenness

First of all, we will eliminate the nodes without connections, i.e., degree equals $0$.

:::: {style="display: grid; grid-template-columns: auto auto; grid-column-gap: 5px; place-items: start;"}
::: {}
__R commands__ 

```{r}
net = delete_vertices(net, which(igraph::degree(net) < 1))
```
:::
::: {}
__Comments__ 

* `delete_vertices(x, y)`: Delete vertices `y` from a graph `x`;
* `degree(x)`: compute the degree for each node of graph `x`;
* `which(igraph::degree(x) < 1)`: return the index where the nodes of the graph `x` has degree less than $1$. 
:::
::::

Then, also we can se which are the nodes with high degree:

```{r}
D_net = igraph::degree(net)
sort(D_net,decreasing = T)[1:5]
```

and we can represent the nodes in a histogram:

```{r}
par(mfrow=c(1,2))
hist(D_net,nclass = 100, main = "Degree distribution", xlab = "Degree")
hist(igraph::degree(net,normalized = T),nclass=100, main = "Degree distribution (normalized)", xlab = "Normalized degree")
```

We can compute also the graph density, which is the ratio of the number of edges and the number of possible edges.

```{r}
edge_density(graph = net)
```


The network follows a `` power-law`` structure, where the distribution of the nodes has an exponential decay as the degree increases: many nodes have a small number of connections ($1$ or $2$), while a small number of nodes have many. Clearly the shape of the distribution does not change when considering the normalised or absolute quantity (all degrees are divided by $(V - 1)$). The distribution of normalised degrees, however, allows us to observe that even the most connected nodes present a small number small number of connections, compared to the size of the network. This result is not surprising,
if we consider that the density of the network is about $0.004$. That is, of all the possible connections, we observe approximately $4$ out of $1000$.


A fundamental concept is the *geodesic distance*, i.e., the length of the shortest path connecting two nodes. The `igraph` library computes this quantities efficiently. For example, to calculate the path connecting two nodes,

```{r}
shortest_paths(graph = net,from = "aiden7757",to = "_nickluna_")$vpath
```

So, the shortest path includes $5$ vertices names `aiden7757`, ` andyhashtagger`, `bgarner2107`, `politweecs` and `_nickluna_`.

We are now interested to compute the mean distance between nodes, i.e., the mean length of the paths:

```{r}
average.path.length(graph = net)
```

So the average path length equals $5.15$. Also, we can compute the matrix $S$ of total distances between all possible couples of nodes:

```{r}
par(mfrow = c(1,1))
S = distances(graph = net)
image(S,col = gray.colors(n = diameter(net)))
```

In addition to the *degree*, there are other measures to assess the importance of a node within the network. The most important are 

- *closeness*: how many steps is required to access every other vertex from a given vertex.

- *betweenness*: the number of geodesics (shortest paths) going through a vertex or an edge.

```{r}
C_net = igraph::closeness(graph = net)
B_net = igraph::betweenness(graph = net)
```

It is possible that we have group of nodes disconnected, in order to see how our network is composed we can use the `components()` function:

```{r}
subg = components(graph = net)
subg$csize
```

The network we are analysing has a very extensive component, consisting of 1149 nodes, and several components consisting of very few nodes (2 or 4). There is also a component formed by 35 nodes, which forms an isolated group and which may be interesting to analyse at a later date. For the moment, we focus only on the largest component, excluding the other nodes from the analysis. We recalculate the statistics mentioned above and evaluate which nodes are associated with higher values.

```{r}
net = igraph::delete.vertices(net, which(subg$membership != 1))
C_net = igraph::closeness(graph = net,normalized = T)
B_net = igraph::betweenness(graph = net,normalized = T)
D_net = igraph::degree(net,normalized = T)
```

```{r}
sort(C_net,decreasing = T)[1:5]
sort(D_net,decreasing = T)[1:5]
sort(B_net,decreasing = T)[1:5]
```

So, let see now the distribution of the closeness and betweeness measure:

```{r}
par(mfrow=c(1,2))
hist(C_net, breaks = 50)
hist(B_net, breaks = 50)
```

Closeness presents a bimodal distribution, with one around $0.16$ and another on higher values. Betweenness, on the other hand, presents a strongly asymmetrical distribution.
For example,

```{r}
sum(B_net > .1)
```

We observe that only 6 nodes have a betweennes greater than 0.1.
We might also ask if and how these statistics are related. For example, as
as the degree increases, so do betwennes and closeness?

```{r}
cor(cbind(B_net,D_net,C_net))
```

```{r}
library(GGally)
ggpairs((data.frame(B_net,D_net,C_net))) + theme_bw()
```

The data suggest that there is some association between grade and betweennes (as one might expected in this example).

# Network and group

The Russian troll network is clearly characterised by different groups. Of particular interest is, for instance, the type of account, which is divided into several macro-categories. There is also a less fine division.

```{r}
aType = vertex_attr(graph = net,name="accounttype")
```

We clean up the various strings with the use of some regular expressions. Note that `$ ` makes a match for an empty string (`^` represents the beginning of a line,`$` the end), and that the $?$ must be preceded by the escape characters `\`.

```{r}
require(stringr)
aType = str_to_title(aType)
aType = str_replace(aType,"Ukranian","Russian")
aType = str_replace(aType,"Commercial|Local","News")
aType = str_replace(aType,"Koch","Fear")
aType = str_replace(aType,"^$|Arabic|\\?", "Other")
table(aType)
```

At this point, we may be interested in some characteristics of our groups. For
for example, how does the distribution of rank and centrality vary between the three largest groups?

```{r}
require(tidyverse)
df_pl = data.frame(den=D_net, clos = C_net, bet = B_net, x=aType)
#gather(df_pl,"den","clos","bet")
df_pl %>% dplyr::filter(x %in% c("Right","Left","Russian")) %>%
gather(.,"den","clos","bet",key="stat",value = "value") %>%
ggplot(aes(value,after_stat(density),color=x)) + geom_freqpoly(lwd=1)+ facet_wrap(~stat,scales="free")+ theme_bw()
```

As discussed in class, in general we do not expect there to be much difference from these statistics if the communities represent reasonable social groups. I
three groups are homogeneous with respect to degree and betweenness, while they differ somewhat in
with respect to closeness. Thus, we can conclude that the group of trolls categorised
as Left are less close to each other than the others. This characteristic is in itself
interesting, and suggests that this group is less compact and therefore also more open
to connections with the outside world. To explore these considerations further, we could evaluate
for instance, how the geodesic distance varies between the two groups, and whether these differences are due to
due only to a few nodes.
A natural question at this point is whether the division into groups is 'good' in terms of
cohesion.

```{r}
modularity(net,factor(aType))
assortativity(net,factor(aType))
```

The division actually leads to very high values of assortativity, confirming a strong homophily
with respect to the group. This result confirms that trolls tend to interact more
with others belonging to the same political sphere or sphere of interest, creating many connections
between profiles that are similar to them and few with those that are different.

# Subgroups and communities

Can we do better? We try to obtain a more interesting partition by estimating the
groups on the basis of connections (the groups from before do not use this information!).

```{r}
gr = cluster_louvain(graph = net)
#gr2 = cluster_fast_greedy(graph = net)
table(membership(gr))
assortativity(net,membership(gr))
```

The method identifies K=10 communities (too many?), and produces a partition with very high modularity. What is the relationship between the groups identified by the Louvain method and those referred to the sphere of influence?

```{r}
table(membership(gr), aType)
```


# Concluding

> `r emo::ji("boom")` **_Please note_** _save your workspace! We will use the objects created today in the next tutorial._

```{r}
save(list = ls(), file = "lab02.RData")
```
